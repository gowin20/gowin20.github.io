<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;1,100;1,300;1,400;1,700&family=Montserrat:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,900&display=swap" rel="stylesheet">  
  <link rel="icon" type="image/x-icon" href="/images/favicon.ico">

  <title>Fractal SVGs</title>

</head>
<body>
<div class="org">
    
<div id="sidebar">


<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI="
crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
    integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM="
    crossorigin=""></script>

<!-- Load Esri Leaflet from CDN -->
<div id="cornerMap"></div>
<script src="https://unpkg.com/esri-leaflet@^3.0.8/dist/esri-leaflet.js"></script>
<script src="https://unpkg.com/esri-leaflet-vector@4.0.0/dist/esri-leaflet-vector.js"></script>
<script>

    //34.04523, -118.25701
    const lat = (Math.random() *0.04) + 34.04523
    const long = (Math.random() *0.04) + -118.25701

    var map = new L.Map("cornerMap", {
        center: new L.LatLng(lat, long),
        zoom:13,
        minZoom:13,
        maxZoom:13,
        zoomControl:false,
        dragging:false,
    });

    const apiKey = "AAPK4bcb23df38f348258205214f35ff7fd3DlCWuDcMvn7vEz4lrQM0U6uXU8RrOpHkWwNWC_4uaK_zh8GDHbfGo4h47UT2I0-U";

    const itemID = "f04f33b9626240f084cb52f0b08758ef";
    L.esri.Vector.vectorBasemapLayer(itemID, {
        apiKey: apiKey
    }).addTo(map);

    document.getElementsByClassName( 'leaflet-control-attribution' )[0].style.display = 'none';
</script>
<div onclick="location.href='/blog'" class="side-name">GEORGE OWEN</div>
<div onclick="location.href='/blog'" class="side-name-mini">OWEN</div>



<div id="scroller-anchor"></div> 

<div class="nav"> 
<ul id="navlist">
    <li onclick="location.href='/';" style="cursor: pointer;" class="navItem" id="nav-0">
        <div class="nav-img" id="nav-art-0"><img src="/images/nav-off.svg" alt=""/></div>
        <span>home</span>
    </li>
    <li onclick="location.href='/blog';" style="cursor: pointer;" class="navItem" id="nav-2">
        <div class="nav-img" id="nav-art-2"><img src="/images/nav-off.svg" alt=""/></div>
        <span>blog</span>
    <!--/li>
        <li onclick="location.href='/about';" style="cursor: pointer;" class="navItem" id="nav-1">
        <div class="nav-img" id="nav-art-1"><img src="/images/nav-off.svg" alt=""/></div>
        <span>photos</span>
    </li-->
</ul>
</div>
  <script>
    const urls = [
    ".dev/$", //TODO change this to live domain extension!
    "/about",
    "/blog*"
    ]

    const navImg_ON = `<img src="/images/nav-on.svg" alt=""/>`
    const navImg_OFF = `<img src="/images/nav-off.svg" alt=""/>`
    const navImg_ON_H = `<img src="/images/nav-on-h.png" alt=""/>`
    const navImg_OFF_H = `<img src="/images/nav-off-h.svg" alt=""/>`

    const navItems = document.getElementsByClassName("navItem");

    const thisUrl = String(window.location);
    for (let i=0;i<navItems.length;i++) {
        const navImg = document.getElementById("nav-art-"+i);
        const navItem = document.getElementById("nav-"+i);
        if (thisUrl.match(urls[i])) {
            //add img to current active
            navImg.innerHTML= navImg_ON;

            navItem.classList += " activeNav";
        }
        else {
            
            navItem.addEventListener("mouseover",()=>{
                navImg.innerHTML = navImg_OFF_H;
            });
            navItem.addEventListener("mouseout",()=>{
                navImg.innerHTML = navImg_OFF;
            });
        }
    }
    //let activePage = document.getElementByID("activeNav");



  </script>






</div>

    <div class="content-pane">
    
<div class="post-bg">
<div class="content-spacing">
    <div class="post-size">

    <header class="post-title">
        Fractal SVGs
    </header>
    Sun Mar 19 2023 00:00:00 GMT+0000 (Coordinated Universal Time)

    <main class="post-content">
            <article><p>I love fractals. I see them in everything, and I've spent way too much time watching <a href="https://www.youtube.com/watch?v=LhOSM6uCWxk">Mandelbrot Fractal Zoom</a> videos on Youtube. It's only natural that I figured out how to generate them programmatically as soon as I learned about SVG Paths.</p>
<p>I created a simple <a href="/fractal-svg">Fractal SVG Generator</a> that recursively creates self-similar images following a set pattern.</p>
<p>Here's an example of what I'm talking about. Let's create a fractal out of the following pattern, called the &quot;Minkowski Sausage&quot;:</p>
<img class="blog-visual" src="/assets/images/6EC2AsQ-4S-1502.jpeg" alt="Minkowski Sausage, Depth 1" loading="lazy" decoding="async">
<p>A simple squiggle. Now, imagine that every line segmet that comprises the pattern gets replaces by a smaller version of the entire pattern:</p>
<img class="blog-visual" src="/assets/images/By6zeTLHa0-1249.jpeg" alt="Minkowski Sausage, Depth 2" loading="lazy" decoding="async">
<p>All eight line segments in the original pattern got replaced by smaller vesions of the pattern. Continuing this infinitely would give us a true fractal. Given the laggy nature of SVGs, we can only generate fractal-like patterns of a relatively small depth before everything starts freezing up. Here's the same Minkowski Sausage at depth 4:</p>
<img class="blog-visual" src="/assets/images/YPGJZqWHrn-1201.jpeg" alt="Minkowski Sausage, Depth 4" loading="lazy" decoding="async">
<p>Even at such a low depth, it already looks cool! This tool can be used to generate simple SVGs representing fractal patterns, which have many use cases. It is not an attempt to perfectly recreate fractals, and it was created entirely for fun.</p>
<p>This is also a great way to learn more about SVGs. If you want to recreate this program yourself, read onwards!</p>
<h3>Prerequisites</h3>
<p>To get the most out of this article, you need:</p>
<ul>
<li>A basic understanding of how SVGs work</li>
<li>A basic understanding of recursion</li>
<li>A basic understanding of trigonometry</li>
</ul>
<p>That's pretty much it. This is a simple concept.</p>
<h3>SVG paths</h3>
<p>The type of fractals we're interested in take the form of a single line. For a fractal with a depth limit, you can describe that line as a finite series of instructions that explain when to draw and when to turn. Enter the SVG <code>&lt;path&gt;</code> option.</p>
<p>For beginner programmers, you can think of a <code>&lt;path&gt;</code> similar to a <a href="https://www.geeksforgeeks.org/turtle-programming-python/">turtle</a> in Python or sprites in <a href="https://scratch.mit.edu/">Scratch</a>. A <code>&lt;path&gt;</code> description provides a set of instructions to an invisible agent that draws lines. You control the agent by telling it to move to a set of spatial coordinates, drawing a line as it goes. This is highly simplified, and there are many more complex operations that you can perform using SVG paths. Today we're only going to use the <code>l</code> instruction.</p>
<pre><code>&lt;path d=&quot;l 20 0&quot;&gt;&lt;/path&gt;
</code></pre>
<p>This will draw a line from <code>0,0</code> to <code>20,0</code> in the SVG view box. Let's use this to create an SVG.</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; fill=&quot;#ffffff&quot; stroke=&quot;#000000&quot; viewBox=&quot;0 0 20 20&quot;&gt;
    &lt;path d=&quot;l 20 0&quot;&gt;&lt;/path&gt;
&lt;/svg&gt;
</code></pre>
<p>This is a simple SVG of a line.</p>
<h3>Fractal paths</h3>
<p>For now, let's focus entirely on generating a <code>&lt;path&gt;</code> that represents a fractal. We'll leave the SVG tags behind and enter a JavaScript file to generate SVGs programmatically.</p>
<pre><code>function drawPattern() {
    let fractalPath = ``;
    return fractalPath;
}
</code></pre>
<p>The <code>drawPattern</code> function will create the contents of the <code>d</code> parameter for a <code>&lt;path&gt;</code>. Adding recursion to this function will enable us to generate fractal SVGs.</p>
<pre><code>function drawPattern(depth, max) {

    let fractalPath = ``

    if (depth &lt; max) {
        // Recursive call
        fractalPath += drawPattern(depth+1,max)
    }
    else {
        fractalPath += `l 0 5 `
    }

    return fractalPath;
}
</code></pre>
<p>This introduces recursion, but the output is still trivial. To create a path that looks like a fractal, we need to provide a pattern for the program to follow. That means that we need to create a system of instructions for moving the path around.</p>
<p>I chose to implement a very simple system. All input to the <code>&lt;path&gt;</code> will be determined by a list containing two different instructions: <code>DRAW</code> and <code>TURN</code>. The <code>&quot;DRAW&quot;</code> instruction will move the pointer forward a set amount, while any integer input will be interpreted as a number of degrees to turn. Being able to &quot;turn&quot; our lines means we can draw complex fractal patterns.</p>
<p>Here's an example of a set of instructions that draws a square:</p>
<pre><code>[&quot;DRAW&quot;,90,&quot;DRAW&quot;,90,&quot;DRAW&quot;,90,&quot;DRAW&quot;]
</code></pre>
<p>To implement this, we will need to store the current heading of the pointer in a global.</p>
<pre><code>let heading = 0;
</code></pre>
<p>Now, to intepret the different instructions:</p>
<pre><code>pattern.forEach(instruction =&gt; {
    if (instruction == &quot;DRAW&quot;) {
        // Draw a line in the direction of heading
    }
    else {
        heading += instruction;
        heading %= 360;
    }
})
</code></pre>
<p>We'll use our good friend trigonometry to interpret the <code>heading</code> and create a line to the proper coordinates:</p>
<pre><code>if (instruction == &quot;DRAW&quot;) {

    // Draw a line in the direction of heading
    const headingRad = (Math.PI * heading) / 180;

    const dy = (size * Math.sin(headingRad));
    const dx = (size * Math.cos(headingRad));
    fractalPath += `l ${dx} ${dy} `

}
</code></pre>
<p>This translates the heading into a pair of vectors <code>dy</code> and <code>dx</code>, then uses them to add a new <code>l</code> instruction to the path. Doing this recursively will create the fractals we are seeking. The only problem remaining is the <code>size</code> - we need the size to scale based on the depth in the fractal.</p>
<pre><code>const size = 5 * depth
</code></pre>
<p>Perfect. Let's add everything together into one recursive function:</p>
<pre><code>const pattern = [&quot;DRAW&quot;,90,&quot;DRAW&quot;,90,&quot;DRAW&quot;,90,&quot;DRAW&quot;]

function drawPattern(depth, max) {

    const size = 5 * depth;
    let fractalPath = ``;

    pattern.forEach(instruction =&gt; {
        if (instruction == &quot;DRAW&quot;) {

            if (depth+1 &lt; max) {
                fractalPath += drawPattern(depth+1,max)
            }
            else {
                fractalPath += `l 0 5 `
            }

            // Draw a line in the direction of heading
            const headingRad = (Math.PI * heading) / 180;

            const dy = (size * Math.sin(headingRad));
            const dx = (size * Math.cos(headingRad));
            fractalPath += `l ${dx} ${dy} `
        }
        else {
            heading += instruction;
            heading %= 360;
        }
    })

    return fractalPath;
}
</code></pre>
<p>And that's the core logic behind the system. Despite how short the code is, there is a large amount of complexity behind how the system works. This function can take in any pattern described in the language of moving and turning, and will generate a fractal version of that pattern. It does so by iteratively replacing each line in the pattern with a smaller version of that pattern. The only requirement for patterns is that they end at the same y-level as they began.</p>
<p>Here's an example of how this function can be used to generate an SVG:</p>
<pre><code>// Minkowski Sausage (Fractal dimension 1.5)
const pattern = [&quot;DRAW&quot;,90,&quot;DRAW&quot;,-90,&quot;DRAW&quot;,-90,&quot;DRAW&quot;,&quot;DRAW&quot;,90,&quot;DRAW&quot;,90,&quot;DRAW&quot;,-90,&quot;DRAW&quot;];
const depth = 4;

// Generate path
const path = drawPattern(0,maxDepth);

// Create SVG element
const fractalSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
const fractalPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

fractalPath.setAttribute('d', path);
fractalSVG.appendChild(fractalPath);

return fractalSVG
</code></pre>
<p>My <a href="/fractal-svg">fractal svg</a> site uses this logic to generate many different patterns. If you have any ideas for more patterns please let me know! I'm also looking to expand this system if anyone has suggestions.</p>
</article>
    </main>

    </div>

    <a href="/blog" class="backButton"><- back</a>

</div>
</div>

    </div>
</div>
</body>
</html>